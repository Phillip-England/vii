<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>vii — Minimal servers in Go</title>
  <style>
    :root{
      --bg:#0b0e14; --panel:#111827; --text:#e5e7eb; --muted:#9ca3af;
      --code:#0f172a; --border:#24304a; --accent:#60a5fa; --accent2:#34d399;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font:15px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:linear-gradient(180deg, #070a10, #0b0e14 40%, #070a10);
      color:var(--text);
    }
    header{
      border-bottom:1px solid var(--border);
      background:rgba(17,24,39,.55);
      backdrop-filter: blur(8px);
      position: sticky; top: 0;
    }
    .wrap{max-width:980px; margin:0 auto; padding:24px}
    h1{margin:0 0 6px 0; font-size:28px; letter-spacing:.2px}
    .subtitle{color:var(--muted); margin:0}
    nav{
      display:flex; flex-wrap:wrap; gap:10px; margin-top:14px;
    }
    nav a{
      text-decoration:none; color:var(--text);
      padding:6px 10px; border:1px solid var(--border);
      border-radius:999px; background:rgba(15,23,42,.35);
      font-size: 13px;
    }
    nav a:hover{border-color:var(--accent); color:var(--accent)}
    main{padding:24px}
    section{
      border:1px solid var(--border); border-radius:14px;
      background:rgba(17,24,39,.35);
      padding:18px 18px; margin:16px 0;
    }
    h2{margin:0 0 10px; font-size:20px}
    h3{margin:24px 0 8px; font-size:16px; color:var(--accent2)}
    p{margin:10px 0; color:var(--text)}
    ul{margin:8px 0 0 20px; color:var(--text)}
    code, pre{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
    pre{
      margin:10px 0; padding:14px 14px; overflow:auto;
      background:rgba(15,23,42,.7); border:1px solid var(--border);
      border-radius:12px;
    }
    .callout{
      padding:12px 14px; border-left:3px solid var(--accent);
      background:rgba(96,165,250,.08); border-radius:10px; margin:10px 0;
      color:var(--text);
    }
    .muted{color:var(--muted)}
    .grid{
      display:grid; grid-template-columns:1fr; gap:12px;
    }
    @media (min-width: 860px){
      .grid{grid-template-columns:1fr 1fr}
    }
    .pill{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid var(--border); color:var(--muted); font-size:12px;
      margin-left:8px;
      vertical-align: middle;
    }
    footer{padding:26px 24px; color:var(--muted); border-top:1px solid var(--border)}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>vii</h1>
      <p class="subtitle">Minimal servers in Go — ergonomic routes, validators, services, websockets, and static/embedded assets.</p>
      <nav>
        <a href="#install">Install</a>
        <a href="#cli">CLI</a>
        <a href="#quickstart">Quickstart</a>
        <a href="#mental-model">Mental model</a>
        <a href="#routes">Routes</a>
        <a href="#validators">Validators</a>
        <a href="#services">Services</a>
        <a href="#builtins">Built-ins</a>
        <a href="#templates">Templates</a>
        <a href="#context">Context</a>
        <a href="#errors">Errors</a>
        <a href="#ws">WebSockets</a>
      </nav>
    </div>
  </header>

  <main class="wrap">
    
    <section id="install">
      <h2>Install</h2>
      <pre><code>go get github.com/phillip-england/vii@latest</code></pre>
      <p class="muted">Import path:</p>
      <pre><code>import vii "github.com/phillip-england/vii/vii"</code></pre>
    </section>

    <section id="cli">
      <h2>CLI Tool <span class="pill">Scaffolding</span></h2>
      <p>vii comes with a CLI to generate your project structure and reduce boilerplate.</p>
      <div class="grid">
        <div>
          <h3>1. Build the tool</h3>
          <pre><code># Inside the repo
go build -o vii main.go
# Move to path
mv vii /usr/local/bin/</code></pre>
        </div>
        <div>
          <h3>2. Usage</h3>
          <pre><code># Create new project
vii init my-app github.com/me/my-app

# Generate components
vii route auth_login
vii service auth
vii validator user_creds</code></pre>
        </div>
      </div>
    </section>

    <section id="quickstart">
      <h2>Quickstart</h2>
      <p class="muted">A minimal server that serves embedded files.</p>
      <pre><code>package main
import (
  "embed"
  "io/fs"
  "log"
  "net/http"
  vii "github.com/phillip-england/vii/vii"
)

//go:embed static/*
var assets embed.FS

func main() {
  app := vii.New()
  
  // 1. Static Files
  static, _ := fs.Sub(assets, "static")
  app.ServeEmbeddedFiles("/", static)

  // 2. Global Middleware
  app.Use(vii.LoggerService{})

  log.Println("Listening on :8080")
  http.ListenAndServe(":8080", app)
}</code></pre>
    </section>

    <section id="mental-model">
      <h2>Mental model</h2>
      <div class="callout">
        <strong>Flow:</strong> Request &rarr; Route Validators &rarr; Service Validators &rarr; Service Before &rarr; <strong>Handler</strong> &rarr; Service After.
      </div>
      <div class="grid">
        <div>
          <h3>Three primitives</h3>
          <ul>
            <li><strong>Routes:</strong> Define endpoints. They are structs, not functions.</li>
            <li><strong>Validators:</strong> Turn raw requests into typed structs.</li>
            <li><strong>Services:</strong> Middleware with a lifecycle (Before/After) and dependencies.</li>
          </ul>
        </div>
        <div>
          <h3>Type-safe Context</h3>
          <ul>
            <li><code>vii.Validated[T](r)</code>: Get data by type.</li>
            <li><code>vii.Valid[T](r, key)</code>: Get data by key.</li>
            <li>No more stringly-typed context maps.</li>
          </ul>
        </div>
      </div>
    </section>

    <section id="routes">
      <h2>Routes <span class="pill">HTTP</span></h2>
      <p>A route is a struct that implements the <code>Route</code> interface.</p>
      <pre><code>type Route interface {
  Handle(r *http.Request, w http.ResponseWriter) error
  OnMount(app *vii.App) error
  OnErr(r *http.Request, w http.ResponseWriter, err error)
}</code></pre>
      <h3>Mounting</h3>
      <pre><code>app.Mount(http.MethodGet, "/users", UserRoute{})
app.MountPattern("POST /users", CreateUserRoute{})</code></pre>
    </section>

    <section id="validators">
      <h2>Validators <span class="pill">Input</span></h2>
      <p>Don't validate in your handler. Validate before you handle.</p>
      <pre><code>type UserID struct { ID string }

type IDValidator struct{}

func (IDValidator) Validate(r *http.Request) (UserID, error) {
    id := r.URL.Query().Get("id")
    if id == "" { return UserID{}, fmt.Errorf("missing id") }
    return UserID{ID: id}, nil
}</code></pre>
      <p>Attach it to a route:</p>
      <pre><code>func (UserRoute) Validators() []vii.AnyValidator {
    return []vii.AnyValidator{
        vii.SV(IDValidator{}), // Store by Type
    }
}

// In Handle:
id, ok := vii.Validated[UserID](r)</code></pre>
    </section>

    <section id="services">
      <h2>Services <span class="pill">Middleware</span></h2>
      <p>Services wrap routes. They can run logic <code>Before</code> and <code>After</code> the handler.</p>
      <pre><code>type Service interface {
  Before(r *http.Request, w http.ResponseWriter) (*http.Request, error)
  After(r *http.Request, w http.ResponseWriter) error
}</code></pre>
      <p class="muted">Services can also declare their own Validators, ensuring dependencies (like Auth) are met before the service logic runs.</p>
    </section>

    <section id="builtins">
      <h2>Built-in Services <span class="pill">batteries-included</span></h2>
      <p>Common functionality ready to use via <code>app.Use()</code>.</p>

      <h3>1. Logger</h3>
      <pre><code>app.Use(vii.LoggerService{})
// Output: [GET][/path][235µs]</code></pre>

      <h3>2. Rate Limiting</h3>
      <pre><code>// Simple RPS limit
app.Use(&vii.RateLimitService{
    Burst: 5,
    RefillEvery: 200 * time.Millisecond, 
})

// Or use helper
app.Use(vii.RateLimitRPS(10, 20)) // 10 req/s, burst 20</code></pre>

      <h3>3. CORS</h3>
      <pre><code>app.Use(vii.CORSService{
    Origin:        true, // Reflect origin
    Credentials:   true,
    AutoPreflight: true, // Handle OPTIONS automatically
})</code></pre>

      <h3>4. CSRF Protection</h3>
      <pre><code>app.Use(vii.CSRFService{
    CookieName: "csrf",
    HeaderName: "X-CSRF-Token",
    // Protects POST, PUT, PATCH, DELETE by default
})</code></pre>
    </section>

    <section id="templates">
      <h2>Templates <span class="pill">html/template</span></h2>
      <p>vii makes Go templates ergonomic with a standard set of helper functions.</p>
      
      <h3>Registration</h3>
      <pre><code>// Register a file system of templates
app.RegisterTemplates("pages", os.DirFS("./views"), vii.TemplateFuncsCommon(), "*.html")</code></pre>

      <h3>Rendering</h3>
      <pre><code>// Inside a route handler
err := vii.Render(r, w, "pages", "home.html", data, nil)</code></pre>

      <h3>Included Functions</h3>
      <div class="grid">
        <div>
          <ul>
            <li><code>lower</code> / <code>upper</code> / <code>title</code></li>
            <li><code>trim</code></li>
            <li><code>printf</code></li>
            <li><code>json</code> (marshals to JS object)</li>
          </ul>
        </div>
        <div>
          <ul>
            <li><code>dict</code> (create maps in templates)</li>
            <li><code>get</code> (safe map access)</li>
            <li><code>default</code> (fallback values)</li>
            <li><code>safeHTML</code></li>
          </ul>
        </div>
      </div>
    </section>

    <section id="context">
      <h2>Context Storage</h2>
      <p>Store data by <strong>Type</strong> (preferred) or by <strong>Key</strong> (advanced).</p>
      <div class="grid">
        <div>
          <h3>By Type</h3>
          <pre><code>// Write
r = vii.WithValidated(r, MyData{...})

// Read
d, ok := vii.Validated[MyData](r)</code></pre>
        </div>
        <div>
          <h3>By Key</h3>
          <pre><code>// Setup Key
var k = vii.NewKey[MyData]("k1")

// Write
r = vii.WithValid(r, k, MyData{...})

// Read
d, ok := vii.Valid[MyData](r, k)</code></pre>
        </div>
      </div>
    </section>

    <section id="errors">
      <h2>Error Handling</h2>
      <h3>Route Level</h3>
      <p>Every route must implement <code>OnErr</code>. This gives you granular control over how errors are rendered (JSON vs HTML) per route.</p>
      <pre><code>func (MyRoute) OnErr(r *http.Request, w http.ResponseWriter, err error) {
    http.Error(w, err.Error(), 500)
}</code></pre>

      <h3>Global Level</h3>
      <p>Hook into all errors for logging/monitoring.</p>
      <pre><code>app.OnErr = func(app *vii.App, route vii.Route, r *http.Request, w http.ResponseWriter, err error) {
    log.Printf("Error on %s: %v", r.URL.Path, err)
}</code></pre>
    </section>

    <section id="ws">
      <h2>WebSockets <span class="pill">Life-cycle Routing</span></h2>
      <p>vii treats WebSocket phases as HTTP methods. You mount one struct to handle the entire lifecycle.</p>
      <pre><code>type ChatSocket struct{}

func (ChatSocket) Handle(r *http.Request, w http.ResponseWriter) error {
    switch r.Method {
    case vii.Method.OPEN:
        fmt.Println("Connected")
    case vii.Method.MESSAGE:
        msg, _ := vii.WSMsg(r)
        // Echo back
        conn, _ := vii.WS(r)
        websocket.Message.Send(conn, msg)
    case vii.Method.CLOSE:
        fmt.Println("Disconnected")
    }
    return nil
}

// Mount
app.Mount(vii.Method.OPEN, "/ws", ChatSocket{})
app.Mount(vii.Method.MESSAGE, "/ws", ChatSocket{})
app.Mount(vii.Method.CLOSE, "/ws", ChatSocket{})</code></pre>
    </section>

  </main>
  
  <footer class="wrap">
    <div>
      <div><strong>vii</strong> — minimal, typed, ergonomic Go servers.</div>
      <div class="muted">Designed for developers who value structure and type safety.</div>
    </div>
  </footer>
</body>
</html>